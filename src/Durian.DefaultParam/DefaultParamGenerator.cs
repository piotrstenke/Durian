using System.Collections.Generic;
using System.Linq;
using Durian.Data;
using Durian.Extensions;
using Durian.Logging;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;

namespace Durian.DefaultParam
{
	[Generator]
	[GeneratorLoggingConfiguration(RelativeToGlobal = true, LogDirectory = "DefaultParam", SupportedLogs = GeneratorLogs.All)]
	public class DefaultParamGenerator : SourceGenerator<DefaultParamCompilationData, DefaultParamSyntaxReceiver, IDefaultParamFilter>
	{
		public static string Version => "1.0.0";
		public static string GeneratorName => nameof(DefaultParamGenerator);
		public const int NumDefaultParamAttributes = 3;

		private readonly DefaultParamRewriter _rewriter;
		private readonly CodeBuilder _builder;
		private readonly string _autoGeneratedAttribute = AutoGenerated.GetAttribute(GeneratorName, Version);

		public DefaultParamGenerator() : this(false)
		{
		}

		public DefaultParamGenerator(bool enableDiagnostics) : base(true, enableDiagnostics)
		{
			_rewriter = new();
			_builder = new(this);
		}

		public DefaultParamGenerator(GeneratorLoggingConfiguration loggingConfiguration) : base(loggingConfiguration)
		{
			_rewriter = new();
			_builder = new(this);
		}

		public override DefaultParamSyntaxReceiver CreateSyntaxReceiver()
		{
			return new DefaultParamSyntaxReceiver(SupportsDiagnostics && EnableDiagnostics);
		}

		protected override FilterContainer<IDefaultParamFilter> GetFilters(in GeneratorExecutionContext context)
		{
			FilterContainer<IDefaultParamFilter> list = new();

			list.RegisterFilterGroup(new IDefaultParamFilter[] { new DefaultParamDelegateFilter(this), new DefaultParamMethodFilter(this) });
			list.RegisterFilterGroup(new IDefaultParamFilter[] { new DefaultParamTypeFilter(this) });

			if (EnableDiagnostics)
			{
				list.RegisterFilterGroup(new IDefaultParamFilter[] { new DefaultParamLocalFunctionFilter(this) });
			}

			return list;
		}

		protected override DefaultParamCompilationData CreateCompilationData(CSharpCompilation compilation)
		{
			return new DefaultParamCompilationData(compilation);
		}

		protected sealed override string GetVersion()
		{
			return Version;
		}

		protected sealed override string GetGeneratorName()
		{
			return GeneratorName;
		}

		public override void Initialize(GeneratorInitializationContext context)
		{
			base.Initialize(context);
			context.RegisterForPostInitialization(AddAttributeSources);
		}

		private void AddAttributeSources(GeneratorPostInitializationContext context)
		{
			InitializeSource(DefaultParamAttribute.CreateSyntaxTree(), DefaultParamAttribute.FullTypeName, in context);
			InitializeSource(DefaultParamConfigurationAttribute.CreateSyntaxTree(), DefaultParamConfigurationAttribute.FullTypeName, in context);
			InitializeSource(DefaultParamMethodConfigurationAttribute.CreateSyntaxTree(), DefaultParamMethodConfigurationAttribute.FullTypeName, in context);
		}

		protected override void BeforeFiltration(in GeneratorExecutionContext context)
		{
			_rewriter.ParentCompilation = TargetCompilation;

			if (EnableDiagnostics)
			{
				DiagnosticReceiver!.SetContext(in context);
			}
		}

		protected override void Generate(IMemberData data, IDefaultParamFilter filter, in GeneratorExecutionContext context)
		{
			if (data is not IDefaultParamTarget target)
			{
				return;
			}

			Generate(target, filter, target.GetHintName(), in context);
		}

		protected void Generate(IDefaultParamTarget target, IDefaultParamFilter filter, string hintName, in GeneratorExecutionContext context)
		{
			WriteTargetLeadDeclaration(target);
			GenerateAllVersionsOfTarget(target, filter, in context);
			_builder.EndAllBlocks();
			AddSource(target.Declaration, _builder, hintName, in context);
		}

		private void WriteTargetLeadDeclaration(IDefaultParamTarget target)
		{
			List<string> list = target.GetUsedNamespaces().ToList();

			if (!list.Contains("System.CodeDom.Compiler"))
			{
				list.Add("System.CodeDom.Compiler");
			}

			_builder.WriteDeclarationLead(target, AnalysisUtilities.SortUsings(list), GeneratorName, Version);
		}

		private void GenerateAllVersionsOfTarget(IDefaultParamTarget target, IDefaultParamFilter filter, in GeneratorExecutionContext context)
		{
			string? inheritdoc;

			if (string.IsNullOrEmpty(target.Symbol.GetDocumentationCommentXml()))
			{
				inheritdoc = null;
			}
			else
			{
				inheritdoc = AutoGenerated.GetInheritdoc(target.GetXmlParentTypesString(true));
			}

			IDefaultParamDeclarationBuilder declBuilder = filter.GetDeclarationBuilder(target, context.CancellationToken);
			_rewriter.Acquire(declBuilder);
			CSharpSyntaxNode[] members = CreateDefaultParamDeclarations(in target.GetTypeParameters());

			if (inheritdoc is null)
			{
				WriteMember(members[0]);

				for (int i = 1; i < members.Length; i++)
				{
					_builder.AppendLine();
					WriteMember(members[i]);
				}
			}
			else
			{
				WriteMemberWithInheritdoc(members[0]);

				for (int i = 1; i < members.Length; i++)
				{
					_builder.AppendLine();
					WriteMemberWithInheritdoc(members[i]);
				}
			}

			void WriteMemberWithInheritdoc(CSharpSyntaxNode node)
			{
				_builder.Indent();
				_builder.AppendLine(inheritdoc);
				_builder.Indent();
				_builder.AppendLine(_autoGeneratedAttribute);
				_builder.Indent();
				_builder.AppendLine(node.ToString());
			}

			void WriteMember(CSharpSyntaxNode node)
			{
				_builder.Indent();
				_builder.AppendLine(_autoGeneratedAttribute);
				_builder.Indent();
				_builder.AppendLine(node.ToString());
			}
		}

		private CSharpSyntaxNode[] CreateDefaultParamDeclarations(in TypeParameterContainer parameters)
		{
			const int originalMemberIndex = 0;
			int originalDataIndex = parameters.Length - 1;
			int originalLength = parameters.NumDefaultParam;

			int length = originalLength;
			int memberIndex = originalMemberIndex;

			// goes from last to first
			int dataIndex = originalDataIndex;

			CSharpSyntaxNode[] members = new CSharpSyntaxNode[length];

			// Types must be replaces separately from the rest.

			while (memberIndex < length)
			{
				ref readonly TypeParameterData data = ref parameters[dataIndex];

				_rewriter.ReplaceType(data.Symbol, AnalysisUtilities.TypeToKeyword(data.TargetType!.Name));

				members[memberIndex] = _rewriter.CurrentNode;

				dataIndex--;
				memberIndex++;
			}

			length = originalLength;
			memberIndex = originalMemberIndex;
			dataIndex = originalDataIndex;

			while (memberIndex < length)
			{
				ref readonly TypeParameterData data = ref parameters[dataIndex];

				_rewriter.Emplace(members[memberIndex]);
				_rewriter.RemoveLastParameter();
				_rewriter.RemoveConstraintsOf(data.Symbol);

				members[memberIndex] = _rewriter.CurrentNode;

				dataIndex--;
				memberIndex++;
			}

			return members;
		}
	}
}
