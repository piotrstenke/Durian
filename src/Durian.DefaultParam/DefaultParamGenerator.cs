using System.Collections.Generic;
using System.Linq;
using Durian.Data;
using Durian.Extensions;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;

namespace Durian.DefaultParam
{
	[Generator]
	public class DefaultParamGenerator : SourceGenerator<DefaultParamCompilationData, DefaultParamSyntaxReceiver, IDefaultParamFilter>
	{
		private static readonly string _autoGeneratedAttribute = AutoGenerated.GetAttribute(GeneratorName, Version);

		public static string Version => "1.0.0";
		public static string GeneratorName => nameof(DefaultParamGenerator);

		private readonly DefaultParamRewriter _rewriter;

		public DefaultParamGenerator()
		{
			_rewriter = new();
		}

		public override DefaultParamSyntaxReceiver CreateSyntaxReceiver()
		{
			return new DefaultParamSyntaxReceiver(EnableDiagnostics);
		}

		protected override FilterList<IDefaultParamFilter> GetFilters(in GeneratorExecutionContext context)
		{
			FilterList<IDefaultParamFilter> list = new();

			list.RegisterFilterGroup(new IDefaultParamFilter[] { new DefaultParamDelegateFilter(), new DefaultParamMethodFilter() });
			list.RegisterFilterGroup(new IDefaultParamFilter[] { new DefaultParamTypeFilter() });

			if (EnableDiagnostics)
			{
				list.RegisterFilterGroup(new IDefaultParamFilter[] { new DefaultParamLocalFunctionFilter() });
			}

			return list;
		}

		protected override DefaultParamCompilationData CreateCompilationData(CSharpCompilation compilation)
		{
			return new DefaultParamCompilationData(compilation);
		}

		protected sealed override string GetVersion()
		{
			return Version;
		}

		protected sealed override string GetGeneratorName()
		{
			return GeneratorName;
		}

		public override void Initialize(GeneratorInitializationContext context)
		{
			base.Initialize(context);
			context.RegisterForPostInitialization(AddAttributeSources);
		}

		private static void AddAttributeSources(GeneratorPostInitializationContext context)
		{
			context.AddSource(DefaultParamAttribute.FullTypeName, DefaultParamAttribute.CreateSourceText());
			context.AddSource(DefaultParamConfigurationAttribute.FullTypeName, DefaultParamConfigurationAttribute.CreateSourceText());
			context.AddSource(DefaultParamMethodConfigurationAttribute.FullTypeName, DefaultParamMethodConfigurationAttribute.CreateSourceText());
		}

		protected override void BeforeFiltration(in GeneratorExecutionContext context)
		{
			_rewriter.ParentCompilation = TargetCompilation;

			if (EnableDiagnostics)
			{
				DiagnosticReceiver.SetContext(in context);
			}
		}

		protected override void Generate(IMemberData data, IDefaultParamFilter filter, CodeBuilder builder, in GeneratorExecutionContext context)
		{
			if (data is not IDefaultParamTarget target)
			{
				return;
			}

			WriteTargetLeadDeclaration(target, builder);
			GenerateAllVersionsOfTarget(target, filter, builder, in context);
			builder.EndAllBlocks();
			EndMemberGeneration(target, builder, in context);
		}

		private void EndMemberGeneration(IDefaultParamTarget target, CodeBuilder builder, in GeneratorExecutionContext context)
		{
			CSharpSyntaxTree tree = builder.ParseSyntaxTree();
			builder.Clear();
			context.AddSource(target.GetHintName(), tree.GetText(context.CancellationToken));
			TargetCompilation.UpdateCompilation(tree);
		}

		private static void WriteTargetLeadDeclaration(IDefaultParamTarget target, CodeBuilder builder)
		{
			List<string> list = target.GetUsedNamespaces().ToList();

			if (!list.Contains("System.CodeDom.Compiler"))
			{
				list.Add("System.CodeDom.Compiler");
			}

			builder.WriteDeclarationLead(target, AnalysisUtilities.SortUsings(list), GeneratorName, Version);
		}

		private void GenerateAllVersionsOfTarget(IDefaultParamTarget target, IDefaultParamFilter filter, CodeBuilder builder, in GeneratorExecutionContext context)
		{
			string? inheritdoc;

			if (string.IsNullOrEmpty(target.Symbol.GetDocumentationCommentXml()))
			{
				inheritdoc = null;
			}
			else
			{
				inheritdoc = AutoGenerated.GetInheritdoc(target.GetXmlParentTypesString(true));
			}

			IDefaultParamDeclarationBuilder declBuilder = filter.GetDeclarationBuilder(target, context.CancellationToken);
			_rewriter.Acquire(declBuilder);
			CSharpSyntaxNode[] members = CreateDefaultParamDeclarations(in target.GetTypeParameters());

			if (inheritdoc is null)
			{
				WriteMember(members[0]);

				for (int i = 1; i < members.Length; i++)
				{
					builder.AppendLine();
					WriteMember(members[i]);
				}
			}
			else
			{
				WriteMemberWithInheritdoc(members[0]);

				for (int i = 1; i < members.Length; i++)
				{
					builder.AppendLine();
					WriteMemberWithInheritdoc(members[i]);
				}
			}

			void WriteMemberWithInheritdoc(CSharpSyntaxNode node)
			{
				builder.Indent();
				builder.AppendLine(inheritdoc);
				builder.Indent();
				builder.AppendLine(_autoGeneratedAttribute);
				builder.Indent();
				builder.AppendLine(node.ToString());
			}

			void WriteMember(CSharpSyntaxNode node)
			{
				builder.Indent();
				builder.AppendLine(_autoGeneratedAttribute);
				builder.Indent();
				builder.AppendLine(node.ToString());
			}
		}

		private CSharpSyntaxNode[] CreateDefaultParamDeclarations(in TypeParameterContainer parameters)
		{
			const int originalMemberIndex = 0;
			int originalDataIndex = parameters.Length - 1;
			int originalLength = parameters.NumDefaultParam;

			int length = originalLength;
			int memberIndex = originalMemberIndex;

			// goes from last to first
			int dataIndex = originalDataIndex;

			CSharpSyntaxNode[] members = new CSharpSyntaxNode[length];

			// Types must be replaces separately from the rest.

			while (memberIndex < length)
			{
				ref readonly TypeParameterData data = ref parameters[dataIndex];

				_rewriter.ReplaceType(data.Symbol, AnalysisUtilities.TypeToKeyword(data.TargetType!.Name));

				members[memberIndex] = _rewriter.CurrentNode;

				dataIndex--;
				memberIndex++;
			}

			length = originalLength;
			memberIndex = originalMemberIndex;
			dataIndex = originalDataIndex;

			while (memberIndex < length)
			{
				ref readonly TypeParameterData data = ref parameters[dataIndex];

				_rewriter.Emplace(members[memberIndex]);
				_rewriter.RemoveLastParameter();
				_rewriter.RemoveConstraintsOf(data.Symbol);

				members[memberIndex] = _rewriter.CurrentNode;

				dataIndex--;
				memberIndex++;
			}

			return members;
		}
	}
}
