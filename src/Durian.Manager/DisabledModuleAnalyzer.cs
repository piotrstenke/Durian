// Copyright (c) Piotr Stenke. All rights reserved.
// Licensed under the MIT license.

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Text;
using Durian.Analysis;
using Durian.Analysis.Extensions;
using Durian.Generator;
using Durian.Info;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Diagnostics;

namespace Durian.Manager
{
	/// <summary>
	/// Collects information about disabled Durian modules.
	/// </summary>
	[DiagnosticAnalyzer(LanguageNames.CSharp)]
	[Generator(LanguageNames.CSharp)]
	public sealed class DisabledModuleAnalyzer : DiagnosticAnalyzer, ISourceGenerator
	{
		private static DurianModule[] _disabledModules = Array.Empty<DurianModule>();

		/// <inheritdoc/>
		public override ImmutableArray<DiagnosticDescriptor> SupportedDiagnostics => ImmutableArray.Create(DurianDiagnostics.DUR0002_ModuleOfTypeIsNotImported);

		/// <summary>
		/// Initializes a new instance of the <see cref="DisabledModuleAnalyzer"/> class.
		/// </summary>
		public DisabledModuleAnalyzer()
		{
		}

		/// <summary>
		/// Returns an array of all modules that are disabled for the current compilation.
		/// </summary>
		public static DurianModule[] GetDisabledModules()
		{
			lock (_disabledModules)
			{
				DurianModule[] modules = new DurianModule[_disabledModules.Length];
				Array.Copy(_disabledModules, modules, _disabledModules.Length);

				return modules;
			}
		}

		/// <summary>
		/// Returns an array of all modules that are enabled for the current compilation.
		/// </summary>
		public static DurianModule[] GetEnabledModules()
		{
			DurianModule[] modules = ModuleIdentity.GetAllModulesAsEnums();
			List<DurianModule> enabled = new(modules.Length);

			foreach (DurianModule module in modules)
			{
				if (IsEnabled(module))
				{
					enabled.Add(module);
				}
			}

			return enabled.ToArray();
		}

		/// <summary>
		/// Checks if the specified <paramref name="module"/> is enabled for the current compilation.
		/// </summary>
		/// <param name="module"><see cref="DurianModule"/> to check for.</param>
		public static bool IsEnabled(DurianModule module)
		{
			lock (_disabledModules)
			{
				foreach (DurianModule m in _disabledModules)
				{
					if (m == module)
					{
						return false;
					}
				}
			}

			return true;
		}

		/// <summary>
		/// Writes the <see cref="EnableModuleAttribute"/> for all the <see cref="DurianModule"/> that are not disabled using the <see cref="DisableModuleAttribute"/>.
		/// </summary>
		/// <param name="builder"><see cref="StringBuilder"/> to write to.</param>
		public static void WriteEnableModuleAttributes(StringBuilder builder)
		{
			DurianModule[] modules = GetEnabledModules();

			if (modules.Length == 0)
			{
				return;
			}

			builder.AppendLine(AutoGenerated.GetHeader());

			foreach (DurianModule module in modules)
			{
				builder
					.Append("[assembly: Durian.Generator.EnableModule(Durian.Info.")
					.Append(nameof(DurianModule))
					.Append('.')
					.Append(module)
					.AppendLine(")]");
			}
		}

		/// <inheritdoc/>
		public override void Initialize(AnalysisContext context)
		{
			context.EnableConcurrentExecution();
			context.ConfigureGeneratedCodeAnalysis(GeneratedCodeAnalysisFlags.None);
			context.RegisterCompilationStartAction(Analyze);
		}

		void ISourceGenerator.Execute(GeneratorExecutionContext context)
		{
			StringBuilder builder = new();
			WriteEnableModuleAttributes(builder);
			context.AddSource("__EnableModules__", builder.ToString());
		}

		void ISourceGenerator.Initialize(GeneratorInitializationContext context)
		{
			// Do nothing.
		}

#pragma warning disable RS1012 // Start action has no registered actions.

		private static void Analyze(CompilationStartAnalysisContext context)
#pragma warning restore RS1012 // Start action has no registered actions.
		{
			INamedTypeSymbol? attribute = context.Compilation.GetTypeByMetadataName("Durian.DisableModuleAttribute");

			if (attribute is null)
			{
				lock (_disabledModules)
				{
					if (_disabledModules.Length > 0)
					{
						_disabledModules = Array.Empty<DurianModule>();
					}
				}

				return;
			}

			List<DurianModule> disabledModules = new(4);

			foreach (AttributeData attr in context.Compilation.Assembly.GetAttributes())
			{
				if (SymbolEqualityComparer.Default.Equals(attr.AttributeClass, attribute) &&
					attr.TryGetConstructorArgumentValue(0, out int value))
				{
					DurianModule module = (DurianModule)value;

					if (DurianInfo.IsValidModuleValue(module))
					{
						disabledModules.Add((DurianModule)value);
					}
				}
			}

			lock (_disabledModules)
			{
				_disabledModules = disabledModules.ToArray();
			}
		}
	}
}
