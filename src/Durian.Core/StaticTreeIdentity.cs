using System;
using System.Collections.Immutable;

namespace Durian.Generator
{
	/// <summary>
	/// Contains basic information about a tree generated by a Durian source generator.
	/// </summary>
	public sealed class StaticTreeIdentity : IEquatable<StaticTreeIdentity>
	{
		internal PackageIdentity _package;

		/// <summary>
		/// Name of the generated type -or- empty <see cref="string"/> if <see cref="Type"/> is equal to <see cref="StaticTreeType.Configuration"/> or <see cref="StaticTreeType.Other"/>.
		/// </summary>
		public string Name { get; }

		/// <summary>
		/// Fully qualified name of the generated type -or- empty <see cref="string"/> if <see cref="Type"/> is equal to <see cref="StaticTreeType.Configuration"/> or <see cref="StaticTreeType.Other"/>.
		/// </summary>
		public string FullyQualifiedName => $"{Namespace}.{Name}";

		/// <summary>
		/// Namespace where the generated type is to be found -or- empty <see cref="string"/> if <see cref="Type"/> is equal to <see cref="StaticTreeType.Configuration"/> or <see cref="StaticTreeType.Other"/> or the type is placed in the <see langword="global"/> namespace.
		/// </summary>
		public string Namespace { get; }

		/// <summary>
		/// Type of this syntax tree.
		/// </summary>
		public StaticTreeType Type { get; }

		/// <summary>
		/// The package this <see cref="StaticTreeIdentity"/> is part of.
		/// </summary>
		public PackageIdentity Package => _package;

		/// <summary>
		/// Sub-trees of this <see cref="StaticTreeIdentity"/>.
		/// </summary>
		public ImmutableArray<StaticTreeIdentity> SubTrees { get; }

		internal StaticTreeIdentity(string name, string @namespace, StaticTreeType type) : this(name, @namespace, type, ImmutableArray.Create<StaticTreeIdentity>())
		{
		}

#pragma warning disable CS8618 // Non-nullable field must contain a non-null value when exiting constructor. Consider declaring as nullable.
		internal StaticTreeIdentity(string name, string @namespace, StaticTreeType type, ImmutableArray<StaticTreeIdentity> subTrees)
#pragma warning restore CS8618 // Non-nullable field must contain a non-null value when exiting constructor. Consider declaring as nullable.
		{
			Name = name;
			Namespace = @namespace;
			Type = type;
			SubTrees = subTrees;
		}

		/// <inheritdoc/>
		public override string ToString()
		{
			return FullyQualifiedName;
		}

		/// <inheritdoc/>
		public override bool Equals(object? obj)
		{
			if(obj is not StaticTreeIdentity other)
			{
				return false;
			}

			return other == this;
		}

		/// <inheritdoc/>
		public bool Equals(StaticTreeIdentity? other)
		{
			return other is not null && other == this;
		}

		/// <inheritdoc/>
		public override int GetHashCode()
		{
			return HashCode.Combine(Name, Namespace, Type, Package, SubTrees);
		}

		/// <inheritdoc/>
		public static bool operator ==(StaticTreeIdentity first, StaticTreeIdentity second)
		{
			return first.Name == second.Name && first.Namespace == second.Name && first.Type == second.Type && first.Package == second.Package && first.SubTrees == second.SubTrees;
		}

		/// <inheritdoc/>
		public static bool operator !=(StaticTreeIdentity first, StaticTreeIdentity second)
		{
			return !(first == second);
		}
	}
}
