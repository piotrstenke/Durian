// Copyright (c) Piotr Stenke. All rights reserved.
// Licensed under the MIT license.

using Durian.Analysis.Data;
using Durian.Analysis.Extensions;
using Durian.Analysis.Logging;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using System;
using System.Diagnostics.CodeAnalysis;
using System.Linq;

namespace Durian.Analysis
{
	/// <summary>
	/// A <see cref="DurianGenerator{TCompilationData, TSyntaxReceiver, TFilter}"/> that uses a <see cref="Analysis.CodeBuilder"/> to generate code.
	/// </summary>
	/// <typeparam name="TCompilationData">User-defined type of <see cref="ICompilationData"/> this <see cref="IDurianGenerator"/> operates on.</typeparam>
	/// <typeparam name="TSyntaxReceiver">User-defined type of <see cref="IDurianSyntaxReceiver"/> that provides the <see cref="CSharpSyntaxNode"/>s to perform the generation on.</typeparam>
	/// <typeparam name="TFilter">User-defined type of <see cref="ISyntaxFilter"/> that decides what <see cref="CSharpSyntaxNode"/>s collected by the <see cref="DurianGenerator{TCompilationData, TSyntaxReceiver, TFilter}.SyntaxReceiver"/> are valid for generation.</typeparam>
	public abstract class DurianGeneratorWithBuilder<TCompilationData, TSyntaxReceiver, TFilter> : DurianGenerator<TCompilationData, TSyntaxReceiver, TFilter>
		where TCompilationData : ICompilationData
		where TSyntaxReceiver : IDurianSyntaxReceiver
		where TFilter : IGeneratorSyntaxFilterWithDiagnostics
	{
		private readonly string _autoGeneratedAttribute;

		/// <summary>
		/// <see cref="Analysis.CodeBuilder"/> that is used to generate code.
		/// </summary>
		public CodeBuilder CodeBuilder { get; }

		/// <inheritdoc cref="DurianGeneratorWithBuilder(in ConstructionContext, IHintNameProvider?)"/>
		protected DurianGeneratorWithBuilder() : this(LoggingConfiguration.Default, null)
		{
		}

		/// <inheritdoc cref="DurianGeneratorWithBuilder(in ConstructionContext, IHintNameProvider?)"/>
		protected DurianGeneratorWithBuilder(in ConstructionContext context) : this(in context, null)
		{
		}

		/// <summary>
		/// Initializes a new instance of the <see cref="DurianGeneratorWithBuilder{TCompilationData, TSyntaxReceiver, TFilter}"/> class.
		/// </summary>
		/// <param name="context">Configures how this <see cref="LoggableGenerator"/> is initialized.</param>
		/// <param name="fileNameProvider">Creates names for generated files.</param>
		protected DurianGeneratorWithBuilder(in ConstructionContext context, IHintNameProvider? fileNameProvider) : base(in context, fileNameProvider)
		{
			CodeBuilder = new(this);
			_autoGeneratedAttribute = AutoGenerated.GetGeneratedCodeAttribute(GetGeneratorName(), GetGeneratorVersion());
		}

		/// <inheritdoc cref="DurianGeneratorWithBuilder(LoggingConfiguration?, IHintNameProvider?)"/>
		protected DurianGeneratorWithBuilder(LoggingConfiguration? loggingConfiguration) : this(loggingConfiguration, null)
		{
		}

		/// <summary>
		/// Initializes a new instance of the <see cref="DurianGeneratorWithBuilder{TCompilationData, TSyntaxReceiver, TFilter}"/> class.
		/// </summary>
		/// <param name="loggingConfiguration">Determines how the source generator should behave when logging information.</param>
		/// <param name="fileNameProvider">Creates names for generated files.</param>
		protected DurianGeneratorWithBuilder(LoggingConfiguration? loggingConfiguration, IHintNameProvider? fileNameProvider) : base(loggingConfiguration, fileNameProvider)
		{
			CodeBuilder = new(this);
			_autoGeneratedAttribute = AutoGenerated.GetGeneratedCodeAttribute(GetGeneratorName(), GetGeneratorVersion());
		}

		/// <summary>
		/// Adds the source created using the <see cref="CodeBuilder"/> to the <paramref name="context"/>.
		/// </summary>
		/// <param name="hintName">An identifier that can be used to reference this source text, must be unique within this generator.</param>
		/// <param name="context"><see cref="GeneratorExecutionContext"/> to add the source to.</param>
		/// <exception cref="InvalidOperationException"><see cref="DurianGenerator{TCompilationData, TSyntaxReceiver, TFilter}.HasValidData"/> must be <see langword="true"/> in order to add new source.</exception>
		protected void AddSource(string hintName, in GeneratorExecutionContext context)
		{
			ThrowIfHasNoValidData();

			CSharpSyntaxTree tree = CodeBuilder.ParseSyntaxTree();
			CodeBuilder.Clear();
			AddSource_Internal(tree, hintName, in context);
		}

		/// <summary>
		/// Adds the source created using the <see cref="CodeBuilder"/> to the <paramref name="context"/>.
		/// </summary>
		/// <param name="original">The <see cref="CSharpSyntaxNode"/> the source was generated from.</param>
		/// <param name="hintName">An identifier that can be used to reference this source text, must be unique within this generator.</param>
		/// <param name="context"><see cref="GeneratorExecutionContext"/> to add the source to.</param>
		/// <exception cref="InvalidOperationException"><see cref="DurianGenerator{TCompilationData, TSyntaxReceiver, TFilter}.HasValidData"/> must be <see langword="true"/> in order to add new source.</exception>
		protected void AddSourceWithOriginal(CSharpSyntaxNode original, string hintName, in GeneratorExecutionContext context)
		{
			ThrowIfHasNoValidData();
			CSharpSyntaxTree tree = CodeBuilder.ParseSyntaxTree();
			CodeBuilder.Clear();
			AddSource_Internal(original, tree, hintName, in context);
		}

		/// <summary>
		/// Adds the text of the <see cref="CodeBuilder"/> to the <paramref name="context"/>.
		/// </summary>
		/// <param name="hintName">An identifier that can be used to reference this source text, must be unique within this generator.</param>
		/// <param name="context"><see cref="GeneratorPostInitializationContext"/> to add the source to.</param>
		protected void InitializeSource(string hintName, in GeneratorPostInitializationContext context)
		{
			CSharpSyntaxTree tree = CodeBuilder.ParseSyntaxTree();
			CodeBuilder.Clear();
			AddSource(tree, hintName, in context);
		}

		/// <summary>
		/// Used to convert the specified <see cref="ISymbol"/> to <see cref="string"/> when applying the <see cref="Generator.DurianGeneratedAttribute"/>.
		/// </summary>
		/// <param name="symbol"><see cref="ISymbol"/> to convert.</param>
		protected virtual string SymbolToString(ISymbol symbol)
		{
			if (symbol is IMethodSymbol method)
			{
				if (method.MethodKind == MethodKind.StaticConstructor)
				{
					return method.GetParentTypesString(false) + ".static " + method.ContainingType.Name + "()";
				}

				if (method.MethodKind == MethodKind.ExplicitInterfaceImplementation && method.ExplicitInterfaceImplementations.Length > 0)
				{
					return method.ExplicitInterfaceImplementations[0].ContainingType.GetGenericName(GenericSubstitution.Arguments) + symbol.ToString();
				}
			}

			return symbol.ToString();
		}

		/// <summary>
		/// Writes the <paramref name="generated"/> <see cref="CSharpSyntaxNode"/> and applies all needed code generation attributes.
		/// </summary>
		/// <param name="generated"><see cref="CSharpSyntaxNode"/> that was generated during the current generation pass.</param>
		/// <param name="original"><see cref="IMemberData"/> this <see cref="CSharpSyntaxNode"/> was generated from.</param>
		/// <param name="applyInheritdoc">Determines when to apply the <c>&lt;inheritdoc/&gt;</c> tag.</param>
		protected void WriteGeneratedMember(CSharpSyntaxNode generated, IMemberData original, GenerateInheritdoc applyInheritdoc = GenerateInheritdoc.WhenPossible)
		{
			WriteGeneratedMember(NodeToString(generated), original, applyInheritdoc);
		}

		/// <summary>
		/// Writes the <paramref name="generated"/> <see cref="string"/> and applies all needed code generation attributes.
		/// </summary>
		/// <param name="generated"><see cref="string"/> that was generated during the current generation pass.</param>
		/// <param name="original"><see cref="IMemberData"/> this <see cref="string"/> was generated from.</param>
		/// <param name="applyInheritdoc">Determines when to apply the <c>&lt;inheritdoc/&gt;</c> tag.</param>
		protected void WriteGeneratedMember(string generated, IMemberData original, GenerateInheritdoc applyInheritdoc = GenerateInheritdoc.WhenPossible)
		{
			string generatedFrom = AutoGenerated.GetDurianGeneratedAttribute(SymbolToString(original.Symbol));

			if (TryGetInheritdoc(original, applyInheritdoc, out string? inheritdoc))
			{
				WriteGeneratedMember_Internal(generated, generatedFrom, inheritdoc);
			}
			else
			{
				WriteGeneratedMember_Internal(generated, generatedFrom);
			}
		}

		/// <summary>
		/// Writes the <paramref name="generated"/> <see cref="CSharpSyntaxNode"/> and applies all needed code generation attributes.
		/// </summary>
		/// <param name="generated"><see cref="CSharpSyntaxNode"/> that was generated during the current generation pass.</param>
		/// <param name="original"><see cref="ISymbol"/> this <see cref="CSharpSyntaxNode"/> was generated from.</param>
		/// <param name="applyInheritdoc">Determines when to apply the <c>&lt;inheritdoc/&gt;</c> tag.</param>
		protected void WriteGeneratedMember(CSharpSyntaxNode generated, ISymbol original, GenerateInheritdoc applyInheritdoc = GenerateInheritdoc.WhenPossible)
		{
			WriteGeneratedMember(NodeToString(generated), original, applyInheritdoc);
		}

		/// <summary>
		/// Writes the <paramref name="generated"/> <see cref="string"/> and applies all needed code generation attributes.
		/// </summary>
		/// <param name="generated"><see cref="string"/> that was generated during the current generation pass.</param>
		/// <param name="original"><see cref="ISymbol"/> this <see cref="string"/> was generated from.</param>
		/// <param name="applyInheritdoc">Determines when to apply the <c>&lt;inheritdoc/&gt;</c> tag.</param>
		protected void WriteGeneratedMember(string generated, ISymbol original, GenerateInheritdoc applyInheritdoc = GenerateInheritdoc.WhenPossible)
		{
			string generatedFrom = AutoGenerated.GetDurianGeneratedAttribute(SymbolToString(original));

			if (TryGetInheritdoc(original, applyInheritdoc, out string? inheritdoc))
			{
				WriteGeneratedMember_Internal(generated, generatedFrom, inheritdoc);
			}
			else
			{
				WriteGeneratedMember_Internal(generated, generatedFrom);
			}
		}

		/// <summary>
		/// Writes the <paramref name="generated"/> <see cref="CSharpSyntaxNode"/> and applies all needed code generation attributes.
		/// </summary>
		/// <param name="generated"><see cref="CSharpSyntaxNode"/> that was generated during the current generation pass.</param>
		protected void WriteGeneratedMember(CSharpSyntaxNode generated)
		{
			WriteGeneratedMember(NodeToString(generated));
		}

		/// <summary>
		/// Writes the <paramref name="generated"/> <see cref="string"/> and applies all needed code generation attributes.
		/// </summary>
		/// <param name="generated"><see cref="string"/> that was generated during the current generation pass.</param>
		protected void WriteGeneratedMember(string generated)
		{
			WriteGeneratedMember_Internal(generated, AutoGenerated.GetDurianGeneratedAttribute());
		}

		/// <summary>
		/// Writes the <paramref name="generated"/> <see cref="CSharpSyntaxNode"/> and applies all needed code generation attributes.
		/// </summary>
		/// <param name="generated"><see cref="CSharpSyntaxNode"/> that was generated during the current generation pass.</param>
		/// <param name="generatedFrom">Name of member this <see cref="CSharpSyntaxNode"/> was generated from.</param>
		protected void WriteGeneratedMember(CSharpSyntaxNode generated, string? generatedFrom)
		{
			WriteGeneratedMember(NodeToString(generated), generatedFrom);
		}

		/// <summary>
		/// Writes the <paramref name="generated"/> <see cref="string"/> and applies all needed code generation attributes.
		/// </summary>
		/// <param name="generated"><see cref="string"/> that was generated during the current generation pass.</param>
		/// <param name="generatedFrom">Name of member this <see cref="string"/> was generated from.</param>
		protected void WriteGeneratedMember(string generated, string? generatedFrom)
		{
			WriteGeneratedMember_Internal(generated, AutoGenerated.GetDurianGeneratedAttribute(generatedFrom));
		}

		/// <summary>
		/// Writes the <paramref name="generated"/> <see cref="CSharpSyntaxNode"/> and applies all needed code generation attributes.
		/// </summary>
		/// <param name="generated"><see cref="CSharpSyntaxNode"/> that was generated during the current generation pass.</param>
		/// <param name="generatedFrom">Name of member this <see cref="CSharpSyntaxNode"/> was generated from.</param>
		/// <param name="inheritdoc">Text to put in the 'inheritdoc' tag.</param>
		protected void WriteGeneratedMember(CSharpSyntaxNode generated, string? generatedFrom, string? inheritdoc)
		{
			WriteGeneratedMember(NodeToString(generated), generatedFrom, inheritdoc);
		}


		/// <summary>
		/// Writes the <paramref name="generated"/> <see cref="string"/> and applies all needed code generation attributes.
		/// </summary>
		/// <param name="generated"><see cref="string"/> that was generated during the current generation pass.</param>
		/// <param name="generatedFrom">Name of member this <see cref="string"/> was generated from.</param>
		/// <param name="inheritdoc">Text to put in the 'inheritdoc' tag.</param>
		protected void WriteGeneratedMember(string generated, string? generatedFrom, string? inheritdoc)
		{
			WriteGeneratedMember_Internal(generated, AutoGenerated.GetDurianGeneratedAttribute(generatedFrom), AutoGenerated.GetInheritdoc(inheritdoc));
		}

		/// <summary>
		/// Writes all the <paramref name="generated"/> <see cref="CSharpSyntaxNode"/>s and applies all needed code generation attributes.
		/// </summary>
		/// <param name="generated"><see cref="CSharpSyntaxNode"/>s that were generated during the current generation pass.</param>
		protected void WriteGeneratedMembers(CSharpSyntaxNode[] generated)
		{
			WriteGeneratedMembers(ConvertString(generated));
		}

		/// <summary>
		/// Writes all the <paramref name="generated"/> <see cref="string"/>s and applies all needed code generation attributes.
		/// </summary>
		/// <param name="generated"><see cref="string"/>s that were generated during the current generation pass.</param>
		protected void WriteGeneratedMembers(string[] generated)
		{
			WriteGeneratedMember(generated[0]);

			int length = generated.Length;
			for (int i = 1; i < length; i++)
			{
				CodeBuilder.WriteLine();
				WriteGeneratedMember(generated[i]);
			}
		}

		/// <summary>
		/// Writes all the <paramref name="generated"/> <see cref="CSharpSyntaxNode"/>s and applies all needed code generation attributes.
		/// </summary>
		/// <param name="generated"><see cref="CSharpSyntaxNode"/>s that were generated during the current generation pass.</param>
		/// <param name="original"><see cref="IMemberData"/> this <see cref="CSharpSyntaxNode"/>s were generated from.</param>
		/// <param name="applyInheritdoc">Determines when to apply the <c>&lt;inheritdoc/&gt;</c> tag.</param>
		protected void WriteGeneratedMembers(CSharpSyntaxNode[] generated, IMemberData original, GenerateInheritdoc applyInheritdoc = GenerateInheritdoc.WhenPossible)
		{
			WriteGeneratedMembers(ConvertString(generated), original, applyInheritdoc);
		}

		/// <summary>
		/// Writes all the <paramref name="generated"/> <see cref="string"/>s and applies all needed code generation attributes.
		/// </summary>
		/// <param name="generated"><see cref="string"/>s that were generated during the current generation pass.</param>
		/// <param name="original"><see cref="IMemberData"/> this <see cref="string"/>s were generated from.</param>
		/// <param name="applyInheritdoc">Determines when to apply the <c>&lt;inheritdoc/&gt;</c> tag.</param>
		protected void WriteGeneratedMembers(string[] generated, IMemberData original, GenerateInheritdoc applyInheritdoc = GenerateInheritdoc.WhenPossible)
		{
			if (generated.Length == 0)
			{
				return;
			}

			string generatedFrom = AutoGenerated.GetDurianGeneratedAttribute(SymbolToString(original.Symbol));
			int length = generated.Length;

			if (TryGetInheritdoc(original, applyInheritdoc, out string? inheritdoc))
			{
				WriteGeneratedMember_Internal(generated[0], generatedFrom, inheritdoc);

				for (int i = 1; i < length; i++)
				{
					CodeBuilder.WriteLine();
					WriteGeneratedMember_Internal(generated[i], generatedFrom, inheritdoc);
				}
			}
			else
			{
				WriteGeneratedMember_Internal(generated[0], generatedFrom);

				for (int i = 1; i < length; i++)
				{
					CodeBuilder.WriteLine();
					WriteGeneratedMember_Internal(generated[i], generatedFrom);
				}
			}
		}

		/// <summary>
		/// Writes all the <paramref name="generated"/> <see cref="CSharpSyntaxNode"/>s and applies all needed code generation attributes.
		/// </summary>
		/// <param name="generated"><see cref="CSharpSyntaxNode"/>s that were generated during the current generation pass.</param>
		/// <param name="original"><see cref="ISymbol"/> this <see cref="CSharpSyntaxNode"/>s were generated from.</param>
		/// <param name="applyInheritdoc">Determines when to apply the <c>&lt;inheritdoc/&gt;</c> tag.</param>
		protected void WriteGeneratedMembers(CSharpSyntaxNode[] generated, ISymbol original, GenerateInheritdoc applyInheritdoc = GenerateInheritdoc.WhenPossible)
		{
			WriteGeneratedMembers(ConvertString(generated), original, applyInheritdoc);
		}

		/// <summary>
		/// Writes all the <paramref name="generated"/> <see cref="string"/>s and applies all needed code generation attributes.
		/// </summary>
		/// <param name="generated"><see cref="string"/>s that were generated during the current generation pass.</param>
		/// <param name="original"><see cref="ISymbol"/> this <see cref="string"/>s were generated from.</param>
		/// <param name="applyInheritdoc">Determines when to apply the <c>&lt;inheritdoc/&gt;</c> tag.</param>
		protected void WriteGeneratedMembers(string[] generated, ISymbol original, GenerateInheritdoc applyInheritdoc = GenerateInheritdoc.WhenPossible)
		{
			if (generated.Length == 0)
			{
				return;
			}

			string generatedFrom = AutoGenerated.GetDurianGeneratedAttribute(SymbolToString(original));
			int length = generated.Length;

			if (TryGetInheritdoc(original, applyInheritdoc, out string? inheritdoc))
			{
				WriteGeneratedMember_Internal(generated[0], generatedFrom, inheritdoc);

				for (int i = 1; i < length; i++)
				{
					CodeBuilder.WriteLine();
					WriteGeneratedMember_Internal(generated[i], generatedFrom, inheritdoc);
				}
			}
			else
			{
				WriteGeneratedMember_Internal(generated[0], generatedFrom);

				for (int i = 1; i < length; i++)
				{
					CodeBuilder.WriteLine();
					WriteGeneratedMember_Internal(generated[i], generatedFrom);
				}
			}
		}

		private static string[] ConvertString(CSharpSyntaxNode[] nodes)
		{
			return nodes.Select(n => NodeToString(n)).ToArray();
		}

		private static string NodeToString(CSharpSyntaxNode node)
		{
			return node.WithoutLeadingTrivia().ToFullString();
		}

		private static bool TryGetInheritdoc(IMemberData original, GenerateInheritdoc applyInheritdoc, [NotNullWhen(true)] out string? inheritdoc)
		{
			switch (applyInheritdoc)
			{
				case GenerateInheritdoc.Always:
					inheritdoc = AutoGenerated.GetInheritdoc(original.GetXmlFullyQualifiedName());
					return true;

				case GenerateInheritdoc.WhenPossible:

					string? doc = original.Symbol.GetInheritdocIfHasDocumentation();

					if (!string.IsNullOrWhiteSpace(doc))
					{
						inheritdoc = doc!;
						return true;
					}

					break;
			}

			inheritdoc = null;
			return false;
		}

		private static bool TryGetInheritdoc(ISymbol original, GenerateInheritdoc applyInheritdoc, [NotNullWhen(true)] out string? inheritdoc)
		{
			switch (applyInheritdoc)
			{
				case GenerateInheritdoc.Always:
					inheritdoc = AutoGenerated.GetInheritdoc(original.GetXmlFullyQualifiedName());
					return true;

				case GenerateInheritdoc.WhenPossible:

					string? doc = original.GetInheritdocIfHasDocumentation();

					if (!string.IsNullOrWhiteSpace(doc))
					{
						inheritdoc = doc!;
						return true;
					}

					break;
			}

			inheritdoc = null;
			return false;
		}

		private void WriteGeneratedMember_Internal(string generated, string generatedFrom)
		{
			CodeBuilder.Indent();
			CodeBuilder.WriteLine(_autoGeneratedAttribute);
			CodeBuilder.Indent();
			CodeBuilder.WriteLine(generatedFrom);
			CodeBuilder.Indent();
			CodeBuilder.WriteLine(generated);
		}

		private void WriteGeneratedMember_Internal(string generated, string generatedFrom, string inheritdoc)
		{
			CodeBuilder.Indent();
			CodeBuilder.WriteLine(inheritdoc);
			WriteGeneratedMember_Internal(generated, generatedFrom);
		}
	}

	/// <inheritdoc cref="DurianGeneratorWithBuilder{TCompilationData, TSyntaxReceiver, TFilter}"/>
	public abstract class DurianGeneratorWithBuilder<TCompilationData, TSyntaxReceiver> : DurianGeneratorWithBuilder<TCompilationData, TSyntaxReceiver, IGeneratorSyntaxFilterWithDiagnostics>
		where TCompilationData : ICompilationData
		where TSyntaxReceiver : IDurianSyntaxReceiver
	{
		/// <inheritdoc cref="DurianGeneratorWithBuilder{TCompilationData, TSyntaxReceiver}.DurianGeneratorWithBuilder(in ConstructionContext, IHintNameProvider?)"/>
		protected DurianGeneratorWithBuilder()
		{
		}

		/// <inheritdoc cref="DurianGeneratorWithBuilder{TCompilationData, TSyntaxReceiver}.DurianGeneratorWithBuilder(in ConstructionContext, IHintNameProvider?)"/>
		protected DurianGeneratorWithBuilder(in ConstructionContext context) : base(in context)
		{
		}

		/// <summary>
		/// Initializes a new instance of the <see cref="DurianGeneratorWithBuilder{TCompilationData, TSyntaxReceiver}"/> class.
		/// </summary>
		/// <param name="context">Configures how this <see cref="LoggableGenerator"/> is initialized.</param>
		/// <param name="fileNameProvider">Creates names for generated files.</param>
		protected DurianGeneratorWithBuilder(in ConstructionContext context, IHintNameProvider? fileNameProvider) : base(in context, fileNameProvider)
		{
		}

		/// <inheritdoc cref="DurianGeneratorWithBuilder(LoggingConfiguration?, IHintNameProvider?)"/>
		protected DurianGeneratorWithBuilder(LoggingConfiguration? loggingConfiguration) : base(loggingConfiguration)
		{
		}

		/// <summary>
		/// Initializes a new instance of the <see cref="DurianGeneratorWithBuilder{TCompilationData, TSyntaxReceiver}"/> class.
		/// </summary>
		/// <param name="loggingConfiguration">Determines how the source generator should behave when logging information.</param>
		/// <param name="fileNameProvider">Creates names for generated files.</param>
		protected DurianGeneratorWithBuilder(LoggingConfiguration? loggingConfiguration, IHintNameProvider? fileNameProvider) : base(loggingConfiguration, fileNameProvider)
		{
		}
	}

	/// <inheritdoc cref="DurianGeneratorWithBuilder{TCompilationData, TSyntaxReceiver, TFilter}"/>
	public abstract class DurianGeneratorWithBuilder<TCompilationData> : DurianGeneratorWithBuilder<TCompilationData, IDurianSyntaxReceiver, IGeneratorSyntaxFilterWithDiagnostics>
		where TCompilationData : ICompilationData
	{
		/// <inheritdoc cref="DurianGeneratorWithBuilder{TCompilationData}.DurianGeneratorWithBuilder(in ConstructionContext, IHintNameProvider?)"/>
		protected DurianGeneratorWithBuilder()
		{
		}

		/// <inheritdoc cref="DurianGeneratorWithBuilder{TCompilationData}.DurianGeneratorWithBuilder(in ConstructionContext, IHintNameProvider?)"/>
		protected DurianGeneratorWithBuilder(in ConstructionContext context) : base(in context)
		{
		}

		/// <summary>
		/// Initializes a new instance of the <see cref="DurianGeneratorWithBuilder{TCompilationData}"/> class.
		/// </summary>
		/// <param name="context">Configures how this <see cref="LoggableGenerator"/> is initialized.</param>
		/// <param name="fileNameProvider">Creates names for generated files.</param>
		protected DurianGeneratorWithBuilder(in ConstructionContext context, IHintNameProvider? fileNameProvider) : base(in context, fileNameProvider)
		{
		}

		/// <inheritdoc cref="DurianGeneratorWithBuilder(LoggingConfiguration?, IHintNameProvider?)"/>
		protected DurianGeneratorWithBuilder(LoggingConfiguration? loggingConfiguration) : base(loggingConfiguration)
		{
		}

		/// <summary>
		/// Initializes a new instance of the <see cref="DurianGeneratorWithBuilder{TCompilationData}"/> class.
		/// </summary>
		/// <param name="loggingConfiguration">Determines how the source generator should behave when logging information.</param>
		/// <param name="fileNameProvider">Creates names for generated files.</param>
		protected DurianGeneratorWithBuilder(LoggingConfiguration? loggingConfiguration, IHintNameProvider? fileNameProvider) : base(loggingConfiguration, fileNameProvider)
		{
		}
	}

	/// <inheritdoc cref="DurianGeneratorWithBuilder{TCompilationData, TSyntaxReceiver, TFilter}"/>
	public abstract class DurianGeneratorWithBuilder : DurianGeneratorWithBuilder<ICompilationData, IDurianSyntaxReceiver, IGeneratorSyntaxFilterWithDiagnostics>
	{
		/// <inheritdoc cref="DurianGeneratorWithBuilder(in ConstructionContext, IHintNameProvider?)"/>
		protected DurianGeneratorWithBuilder()
		{
		}

		/// <inheritdoc cref="DurianGeneratorWithBuilder(in ConstructionContext, IHintNameProvider?)"/>
		protected DurianGeneratorWithBuilder(in ConstructionContext context) : base(in context)
		{
		}

		/// <summary>
		/// Initializes a new instance of the <see cref="DurianGenerator"/> class.
		/// </summary>
		/// <param name="context">Configures how this <see cref="LoggableGenerator"/> is initialized.</param>
		/// <param name="fileNameProvider">Creates names for generated files.</param>
		protected DurianGeneratorWithBuilder(in ConstructionContext context, IHintNameProvider? fileNameProvider) : base(in context, fileNameProvider)
		{
		}

		/// <inheritdoc cref="DurianGeneratorWithBuilder(LoggingConfiguration?, IHintNameProvider?)"/>
		protected DurianGeneratorWithBuilder(LoggingConfiguration? loggingConfiguration) : base(loggingConfiguration)
		{
		}

		/// <summary>
		/// Initializes a new instance of the <see cref="DurianGenerator"/> class.
		/// </summary>
		/// <param name="loggingConfiguration">Determines how the source generator should behave when logging information.</param>
		/// <param name="fileNameProvider">Creates names for generated files.</param>
		protected DurianGeneratorWithBuilder(LoggingConfiguration? loggingConfiguration, IHintNameProvider? fileNameProvider) : base(loggingConfiguration, fileNameProvider)
		{
		}
	}
}
