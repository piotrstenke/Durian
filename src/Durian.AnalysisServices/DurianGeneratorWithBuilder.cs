using System.Diagnostics.CodeAnalysis;
using System.Linq;
using System.Text;
using Durian.Analysis.CodeGeneration;
using Durian.Analysis.Data;
using Durian.Analysis.Extensions;
using Durian.Analysis.Logging;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;

namespace Durian.Analysis
{
	/// <summary>
	/// A <see cref="DurianGenerator"/> that uses a <see cref="CodeBuilder"/> to generate code.
	/// </summary>
	/// <typeparam name="TContext">Type of <see cref="IGeneratorPassContext"/> this generator uses.</typeparam>
	public abstract class DurianGeneratorWithBuilder<TContext> : DurianGenerator<TContext> where TContext : GeneratorPassBuilderContext
	{
		private readonly string _autoGeneratedAttribute;

		/// <summary>
		/// Initializes a new instance of the <see cref="DurianGeneratorWithBuilder{TContext}"/> class.
		/// </summary>
		protected DurianGeneratorWithBuilder()
		{
			_autoGeneratedAttribute = AutoGenerated.GetGeneratedCodeAttribute(GeneratorName, GeneratorVersion);
		}

		/// <summary>
		/// Initializes a new instance of the <see cref="DurianGeneratorWithBuilder{TContext}"/> class.
		/// </summary>
		/// <param name="context">Configures how this <see cref="DurianGeneratorWithBuilder{TContext}"/> is initialized.</param>
		protected DurianGeneratorWithBuilder(in GeneratorLogCreationContext context) : base(in context)
		{
			_autoGeneratedAttribute = AutoGenerated.GetGeneratedCodeAttribute(GeneratorName, GeneratorVersion);
		}

		/// <summary>
		/// Initializes a new instance of the <see cref="DurianGeneratorWithBuilder{TContext}"/> class.
		/// </summary>
		/// <param name="loggingConfiguration">Determines how the source generator should behave when logging information.</param>
		protected DurianGeneratorWithBuilder(LoggingConfiguration? loggingConfiguration) : base(loggingConfiguration)
		{
			_autoGeneratedAttribute = AutoGenerated.GetGeneratedCodeAttribute(GeneratorName, GeneratorVersion);
		}

		/// <summary>
		/// Adds the source created using the <see cref="CodeBuilder"/> to the <paramref name="context"/>.
		/// </summary>
		/// <param name="hintName">An identifier that can be used to reference this source text, must be unique within this generator.</param>
		/// <param name="context"><typeparamref name="TContext"/> to add the source to.</param>
		protected void AddSource(string hintName, TContext context)
		{
			SyntaxTree tree = ParseSyntaxTree(context);
			context.CodeBuilder.Clear();
			AddSource_Internal(tree, hintName, context);
		}

		/// <summary>
		/// Adds the source created using the <see cref="CodeBuilder"/> to the <paramref name="context"/>.
		/// </summary>
		/// <param name="original">The <see cref="SyntaxNode"/> the source was generated from.</param>
		/// <param name="hintName">An identifier that can be used to reference this source text, must be unique within this generator.</param>
		/// <param name="context"><typeparamref name="TContext"/> to add the source to.</param>
		protected void AddSourceWithOriginal(SyntaxNode original, string hintName, TContext context)
		{
			SyntaxTree tree = ParseSyntaxTree(context);
			context.CodeBuilder.Clear();
			AddSource_Internal(original, tree, hintName, context);
		}

		/// <summary>
		/// Used to convert the specified <see cref="ISymbol"/> to <see cref="string"/> when applying the <see cref="Generator.DurianGeneratedAttribute"/>.
		/// </summary>
		/// <param name="symbol"><see cref="ISymbol"/> to convert.</param>
		protected virtual string SymbolToString(ISymbol symbol)
		{
			CodeBuilder builder = new(false);

			switch (symbol)
			{
				case IMethodSymbol method when method.MethodKind == MethodKind.Ordinary:
					WriteMethod(builder, method);
					return builder.ToString();

				case IMethodSymbol method when method.MethodKind == MethodKind.StaticConstructor:
					WriteParentTypesAndNamespaces(builder, method);
					return builder.ToString() + "static " + method.ContainingType.Name + "()";

				case IMethodSymbol method when method.MethodKind == MethodKind.ExplicitInterfaceImplementation:

					if (method.ExplicitInterfaceImplementations.Length == 0)
					{
						WriteMethod(builder, method);
						return builder.ToString();
					}

					IMethodSymbol interfaceMethod = method.ExplicitInterfaceImplementations[0];

					builder.Write('(');
					WriteParentTypesAndNamespaces(builder, interfaceMethod.ContainingType);
					builder.Name(interfaceMethod.ContainingType, SymbolName.Generic);
					builder.Write(')');

					WriteParentTypesAndNamespaces(builder, method);

					builder.Name(interfaceMethod, SymbolName.Generic);
					builder.ParameterList(method);

					return builder.ToString();

				case IMethodSymbol method when method.MethodKind == MethodKind.Constructor:
					WriteParentTypesAndNamespaces(builder, method);

					builder.Write(method.ContainingType.Name);
					builder.Write('(');
					builder.ParameterTypeList(method);
					builder.Write(')');

					return builder.ToString();

				case IMethodSymbol method when method.IsAccessor():

					if (method.AssociatedSymbol is IPropertySymbol prop && prop.IsIndexer)
					{
						WriteIndexer(builder, prop);
					}
					else
					{
						WriteParentTypesAndNamespaces(builder, method);
						builder.Write(method.AssociatedSymbol!.Name);
					}

					return builder.ToString();

				case IMethodSymbol method when method.MethodKind == MethodKind.Destructor:
					WriteParentTypesAndNamespaces(builder, method);
					return builder.ToString() + '~' + method.ContainingType.Name + "()";

				case IMethodSymbol method when method.MethodKind == MethodKind.Conversion:
					string keyword;

					if (method.IsImplicitOperator())
					{
						keyword = "implicit";
					}
					else if (method.IsExplicitOperator())
					{
						keyword = "explicit";
					}
					else
					{
						goto default;
					}

					WriteParentTypesAndNamespaces(builder, method);

					builder.Write(keyword);
					builder.Space();

					builder.Write("operator ");

					builder.Type(method.ReturnType);
					builder.Write('(');
					builder.ParameterTypeList(method);
					builder.Write(')');

					return builder.ToString();

				case IMethodSymbol method when method.MethodKind is MethodKind.UserDefinedOperator or MethodKind.BuiltinOperator:
					if (method.GetOperatorToken() is not string op)
					{
						goto default;
					}

					WriteParentTypesAndNamespaces(builder, method);

					builder.Write("operator ");
					builder.Write(op);

					builder.Write('(');
					builder.ParameterTypeList(method);
					builder.Write(')');

					return builder.ToString();

				case IMethodSymbol method:
					WriteMethod(builder, method);
					return builder.ToString();

				case INamedTypeSymbol type:
					WriteParentTypesAndNamespaces(builder, type);
					builder.Name(type, SymbolName.Generic);
					return builder.ToString();

				case IPropertySymbol property when property.IsIndexer:
					WriteIndexer(builder, property);
					return builder.ToString();

				default:
					WriteParentTypesAndNamespaces(builder, symbol);
					builder.Name(symbol, SymbolName.Generic);
					return builder.ToString();
			}

			static void WriteParentTypesAndNamespaces(CodeBuilder builder, ISymbol symbol)
			{
				foreach (INamespaceOrTypeSymbol s in symbol.GetContainingNamespacesAndTypes())
				{
					builder.Name(s, SymbolName.Generic);
					builder.Write('.');
				}
			}

			static void WriteIndexer(CodeBuilder builder, IPropertySymbol property)
			{
				WriteParentTypesAndNamespaces(builder, property);
				builder.Write("this[");
				builder.ParameterTypeList(property.Parameters);
				builder.Write(']');
			}

			static string WriteMethod(CodeBuilder builder, IMethodSymbol method)
			{
				WriteParentTypesAndNamespaces(builder, method);
				builder.Name(method, SymbolName.Generic);
				builder.Write('(');
				builder.ParameterTypeList(method);
				builder.Write(')');
				return builder.ToString();
			}
		}

		/// <summary>
		/// Writes auto-generated header, using directives and declarations of parent namespaces and types of the specified <paramref name="member"/>.
		/// </summary>
		/// <param name="builder"><see cref="CodeBuilder"/> to write the generated code to.</param>
		/// <param name="member"><see cref="IMemberData"/> to write the declaration lead of.</param>
		/// <param name="usings">Array of usings that should be used in using directives.</param>
		protected void WriteDeclarationLead(CodeBuilder builder, IMemberData member, string[]? usings = default)
		{
			builder.Write(AutoGenerated.GetHeader(GeneratorName, GeneratorVersion));
			builder.NewLine();

			if (usings is not null && usings.Length > 0)
			{
				foreach (string @using in usings)
				{
					builder.Using(@using);
				}

				builder.NewLine();
			}

			if (member.Symbol.ContainingNamespace is not null && !member.Symbol.ContainingNamespace.IsGlobalNamespace)
			{
				builder.Namespace(member.Symbol.ContainingNamespace);
			}

			foreach (INamedTypeSymbol type in member.ContainingTypes.GetSymbols().Cast<INamedTypeSymbol>())
			{
				builder.Declaration(type);
			}
		}

		/// <summary>
		/// Writes the <paramref name="generated"/> <see cref="SyntaxNode"/> and applies all needed code generation attributes.
		/// </summary>
		/// <param name="generated"><see cref="SyntaxNode"/> that was generated during the current generation pass.</param>
		/// <param name="original"><see cref="IMemberData"/> this <see cref="SyntaxNode"/> was generated from.</param>
		/// <param name="context">Current <typeparamref name="TContext"/>.</param>
		/// <param name="includeGenerationAttributes">Determines whether to apply the <see cref="Generator.DurianGeneratedAttribute"/> and <see cref="System.CodeDom.Compiler.GeneratedCodeAttribute"/> attributes to the generated node.</param>
		/// <param name="applyInheritdoc">Determines when to apply the <c>&lt;inheritdoc/&gt;</c> tag.</param>
		protected void WriteGeneratedMember(
			SyntaxNode generated,
			IMemberData original,
			TContext context,
			bool includeGenerationAttributes = true,
			GenerateDocumentation applyInheritdoc = GenerateDocumentation.WhenPossible
		)
		{
			WriteGeneratedMember(NodeToString(generated), original, context, includeGenerationAttributes, applyInheritdoc);
		}

		/// <summary>
		/// Writes the <paramref name="generated"/> <see cref="string"/> and applies all needed code generation attributes.
		/// </summary>
		/// <param name="generated"><see cref="string"/> that was generated during the current generation pass.</param>
		/// <param name="original"><see cref="IMemberData"/> this <see cref="string"/> was generated from.</param>
		/// <param name="context">Current <typeparamref name="TContext"/>.</param>
		/// <param name="includeGenerationAttributes">Determines whether to apply the <see cref="Generator.DurianGeneratedAttribute"/> and <see cref="System.CodeDom.Compiler.GeneratedCodeAttribute"/> attributes to the generated node.</param>
		/// <param name="applyInheritdoc">Determines when to apply the <c>&lt;inheritdoc/&gt;</c> tag.</param>
		protected void WriteGeneratedMember(
			string generated,
			IMemberData original,
			TContext context,
			bool includeGenerationAttributes = true,
			GenerateDocumentation applyInheritdoc = GenerateDocumentation.WhenPossible)
		{
			if (TryGetInheritdoc(original, applyInheritdoc, out string? inheritdoc))
			{
				if(includeGenerationAttributes)
				{
					string generatedFrom = AutoGenerated.GetDurianGeneratedAttribute(SymbolToString(original.Symbol));
					WriteGeneratedMember_Internal(generated, generatedFrom, inheritdoc, context);
				}
				else
				{
					context.CodeBuilder.Indent();
					context.CodeBuilder.WriteLine(inheritdoc);
					context.CodeBuilder.Indent();
					context.CodeBuilder.WriteLine(generated);
					context.CodeBuilder.NewLine();
				}
			}
			else
			{
				if(includeGenerationAttributes)
				{
					string generatedFrom = AutoGenerated.GetDurianGeneratedAttribute(SymbolToString(original.Symbol));
					WriteGeneratedMember_Internal(generated, generatedFrom, context);
				}
				else
				{
					context.CodeBuilder.Indent();
					context.CodeBuilder.WriteLine(generated);
					context.CodeBuilder.NewLine();
				}
			}
		}

		/// <summary>
		/// Writes the <paramref name="generated"/> <see cref="SyntaxNode"/> and applies all needed code generation attributes.
		/// </summary>
		/// <param name="generated"><see cref="SyntaxNode"/> that was generated during the current generation pass.</param>
		/// <param name="original"><see cref="ISymbol"/> this <see cref="SyntaxNode"/> was generated from.</param>
		/// <param name="context">Current <typeparamref name="TContext"/>.</param>
		/// <param name="includeGenerationAttributes">Determines whether to apply the <see cref="Generator.DurianGeneratedAttribute"/> and <see cref="System.CodeDom.Compiler.GeneratedCodeAttribute"/> attributes to the generated node.</param>
		/// <param name="applyInheritdoc">Determines when to apply the <c>&lt;inheritdoc/&gt;</c> tag.</param>
		protected void WriteGeneratedMember(
			SyntaxNode generated,
			ISymbol original,
			TContext context,
			bool includeGenerationAttributes = true,
			GenerateDocumentation applyInheritdoc = GenerateDocumentation.WhenPossible)
		{
			WriteGeneratedMember(NodeToString(generated), original, context, includeGenerationAttributes, applyInheritdoc);
		}

		/// <summary>
		/// Writes the <paramref name="generated"/> <see cref="string"/> and applies all needed code generation attributes.
		/// </summary>
		/// <param name="generated"><see cref="string"/> that was generated during the current generation pass.</param>
		/// <param name="original"><see cref="ISymbol"/> this <see cref="string"/> was generated from.</param>
		/// <param name="context">Current <typeparamref name="TContext"/>.</param>
		/// <param name="includeGenerationAttributes">Determines whether to apply the <see cref="Generator.DurianGeneratedAttribute"/> and <see cref="System.CodeDom.Compiler.GeneratedCodeAttribute"/> attributes to the generated node.</param>
		/// <param name="applyInheritdoc">Determines when to apply the <c>&lt;inheritdoc/&gt;</c> tag.</param>
		protected void WriteGeneratedMember(
			string generated,
			ISymbol original,
			TContext context,
			bool includeGenerationAttributes = true,
			GenerateDocumentation applyInheritdoc = GenerateDocumentation.WhenPossible
		)
		{
			if (TryGetInheritdoc(original, applyInheritdoc, out string? inheritdoc))
			{
				if(includeGenerationAttributes)
				{
					string generatedFrom = AutoGenerated.GetDurianGeneratedAttribute(SymbolToString(original));
					WriteGeneratedMember_Internal(generated, generatedFrom, inheritdoc, context);
				}
				else
				{
					context.CodeBuilder.Indent();
					context.CodeBuilder.WriteLine(inheritdoc);
					context.CodeBuilder.Indent();
					context.CodeBuilder.WriteLine(generated);
					context.CodeBuilder.NewLine();
				}
			}
			else
			{
				if(includeGenerationAttributes)
				{
					string generatedFrom = AutoGenerated.GetDurianGeneratedAttribute(SymbolToString(original));
					WriteGeneratedMember_Internal(generated, generatedFrom, context);
				}
				else
				{
					context.CodeBuilder.Indent();
					context.CodeBuilder.WriteLine(generated);
					context.CodeBuilder.NewLine();
				}
			}
		}

		/// <summary>
		/// Writes the <paramref name="generated"/> <see cref="SyntaxNode"/> and applies all needed code generation attributes.
		/// </summary>
		/// <param name="generated"><see cref="SyntaxNode"/> that was generated during the current generation pass.</param>
		/// <param name="context">Current <typeparamref name="TContext"/>.</param>
		protected void WriteGeneratedMember(SyntaxNode generated, TContext context)
		{
			WriteGeneratedMember(NodeToString(generated), context);
		}

		/// <summary>
		/// Writes the <paramref name="generated"/> <see cref="string"/> and applies all needed code generation attributes.
		/// </summary>
		/// <param name="generated"><see cref="string"/> that was generated during the current generation pass.</param>
		/// <param name="context">Current <typeparamref name="TContext"/>.</param>
		/// <param name="includeGenerationAttributes">Determines whether to apply the <see cref="Generator.DurianGeneratedAttribute"/> and <see cref="System.CodeDom.Compiler.GeneratedCodeAttribute"/> attributes to the generated node.</param>
		protected void WriteGeneratedMember(string generated, TContext context, bool includeGenerationAttributes = true)
		{
			if(includeGenerationAttributes)
			{
				WriteGeneratedMember_Internal(generated, AutoGenerated.GetDurianGeneratedAttribute(), context);
			}
			else
			{
				context.CodeBuilder.Indent();
				context.CodeBuilder.WriteLine(generated);
				context.CodeBuilder.NewLine();
			}
		}

		/// <summary>
		/// Writes the <paramref name="generated"/> <see cref="SyntaxNode"/> and applies all needed code generation attributes.
		/// </summary>
		/// <param name="generated"><see cref="SyntaxNode"/> that was generated during the current generation pass.</param>
		/// <param name="generatedFrom">Name of member this <see cref="SyntaxNode"/> was generated from.</param>
		/// <param name="context">Current <typeparamref name="TContext"/>.</param>
		/// <param name="includeGenerationAttributes">Determines whether to apply the <see cref="Generator.DurianGeneratedAttribute"/> and <see cref="System.CodeDom.Compiler.GeneratedCodeAttribute"/> attributes to the generated node.</param>
		protected void WriteGeneratedMember(SyntaxNode generated, string? generatedFrom, TContext context, bool includeGenerationAttributes = true)
		{
			WriteGeneratedMember(NodeToString(generated), generatedFrom, context, includeGenerationAttributes);
		}

		/// <summary>
		/// Writes the <paramref name="generated"/> <see cref="string"/> and applies all needed code generation attributes.
		/// </summary>
		/// <param name="generated"><see cref="string"/> that was generated during the current generation pass.</param>
		/// <param name="generatedFrom">Name of member this <see cref="string"/> was generated from.</param>
		/// <param name="context">Current <typeparamref name="TContext"/>.</param>
		/// <param name="includeGenerationAttributes">Determines whether to apply the <see cref="Generator.DurianGeneratedAttribute"/> and <see cref="System.CodeDom.Compiler.GeneratedCodeAttribute"/> attributes to the generated node.</param>
		protected void WriteGeneratedMember(string generated, string? generatedFrom, TContext context, bool includeGenerationAttributes = true)
		{
			if (includeGenerationAttributes)
			{
				WriteGeneratedMember_Internal(generated, AutoGenerated.GetDurianGeneratedAttribute(generatedFrom), context);
			}
			else
			{
				context.CodeBuilder.Indent();
				context.CodeBuilder.WriteLine(generated);
				context.CodeBuilder.NewLine();
			}
		}

		/// <summary>
		/// Writes the <paramref name="generated"/> <see cref="SyntaxNode"/> and applies all needed code generation attributes.
		/// </summary>
		/// <param name="generated"><see cref="SyntaxNode"/> that was generated during the current generation pass.</param>
		/// <param name="generatedFrom">Name of member this <see cref="SyntaxNode"/> was generated from.</param>
		/// <param name="inheritdoc">Text to put in the 'inheritdoc' tag.</param>
		/// <param name="context">Current <typeparamref name="TContext"/>.</param>
		/// <param name="includeGenerationAttributes">Determines whether to apply the <see cref="Generator.DurianGeneratedAttribute"/> and <see cref="System.CodeDom.Compiler.GeneratedCodeAttribute"/> attributes to the generated node.</param>
		protected void WriteGeneratedMember(SyntaxNode generated, string? generatedFrom, string? inheritdoc, TContext context, bool includeGenerationAttributes = true)
		{
			WriteGeneratedMember(NodeToString(generated), generatedFrom, inheritdoc, context, includeGenerationAttributes);
		}

		/// <summary>
		/// Writes the <paramref name="generated"/> <see cref="string"/> and applies all needed code generation attributes.
		/// </summary>
		/// <param name="generated"><see cref="string"/> that was generated during the current generation pass.</param>
		/// <param name="generatedFrom">Name of member this <see cref="string"/> was generated from.</param>
		/// <param name="inheritdoc">Text to put in the 'inheritdoc' tag.</param>
		/// <param name="context">Current <typeparamref name="TContext"/>.</param>
		/// <param name="includeGenerationAttributes">Determines whether to apply the <see cref="Generator.DurianGeneratedAttribute"/> and <see cref="System.CodeDom.Compiler.GeneratedCodeAttribute"/> attributes to the generated node.</param>
		protected void WriteGeneratedMember(string generated, string? generatedFrom, string? inheritdoc, TContext context, bool includeGenerationAttributes = true)
		{
			if(includeGenerationAttributes)
			{
				WriteGeneratedMember_Internal(generated, AutoGenerated.GetDurianGeneratedAttribute(generatedFrom), AutoGenerated.GetInheritdoc(inheritdoc), context);
			}
			else
			{
				context.CodeBuilder.Indent();
				context.CodeBuilder.WriteLine(AutoGenerated.GetInheritdoc(inheritdoc));
				context.CodeBuilder.Indent();
				context.CodeBuilder.WriteLine(generated);
				context.CodeBuilder.NewLine();
			}
		}

		/// <summary>
		/// Writes all the <paramref name="generated"/> <see cref="SyntaxNode"/>s and applies all needed code generation attributes.
		/// </summary>
		/// <param name="generated"><see cref="SyntaxNode"/>s that were generated during the current generation pass.</param>
		/// <param name="context">Current <typeparamref name="TContext"/>.</param>
		/// <param name="includeGenerationAttributes">Determines whether to apply the <see cref="Generator.DurianGeneratedAttribute"/> and <see cref="System.CodeDom.Compiler.GeneratedCodeAttribute"/> attributes to the generated node.</param>
		protected void WriteGeneratedMembers(SyntaxNode[] generated, TContext context, bool includeGenerationAttributes = true)
		{
			WriteGeneratedMembers(ConvertString(generated), context, includeGenerationAttributes);
		}

		/// <summary>
		/// Writes all the <paramref name="generated"/> <see cref="string"/>s and applies all needed code generation attributes.
		/// </summary>
		/// <param name="generated"><see cref="string"/>s that were generated during the current generation pass.</param>
		/// <param name="context">Current <typeparamref name="TContext"/>.</param>
		/// <param name="includeGenerationAttributes">Determines whether to apply the <see cref="Generator.DurianGeneratedAttribute"/> and <see cref="System.CodeDom.Compiler.GeneratedCodeAttribute"/> attributes to the generated node.</param>
		protected void WriteGeneratedMembers(string[] generated, TContext context, bool includeGenerationAttributes = true)
		{
			WriteGeneratedMember(generated[0], context, includeGenerationAttributes);

			int length = generated.Length;
			for (int i = 1; i < length; i++)
			{
				context.CodeBuilder.NewLine();
				WriteGeneratedMember(generated[i], context, includeGenerationAttributes);
			}
		}

		/// <summary>
		/// Writes all the <paramref name="generated"/> <see cref="SyntaxNode"/>s and applies all needed code generation attributes.
		/// </summary>
		/// <param name="generated"><see cref="SyntaxNode"/>s that were generated during the current generation pass.</param>
		/// <param name="original"><see cref="IMemberData"/> this <see cref="SyntaxNode"/>s were generated from.</param>
		/// <param name="context">Current <typeparamref name="TContext"/>.</param>
		/// <param name="includeGenerationAttributes">Determines whether to apply the <see cref="Generator.DurianGeneratedAttribute"/> and <see cref="System.CodeDom.Compiler.GeneratedCodeAttribute"/> attributes to the generated node.</param>
		/// <param name="applyInheritdoc">Determines when to apply the <c>&lt;inheritdoc/&gt;</c> tag.</param>
		protected void WriteGeneratedMembers(
			SyntaxNode[] generated,
			IMemberData original,
			TContext context,
			bool includeGenerationAttributes = true,
			GenerateDocumentation applyInheritdoc = GenerateDocumentation.WhenPossible
		)
		{
			WriteGeneratedMembers(ConvertString(generated), original, context, includeGenerationAttributes, applyInheritdoc);
		}

		/// <summary>
		/// Writes all the <paramref name="generated"/> <see cref="string"/>s and applies all needed code generation attributes.
		/// </summary>
		/// <param name="generated"><see cref="string"/>s that were generated during the current generation pass.</param>
		/// <param name="original"><see cref="IMemberData"/> this <see cref="string"/>s were generated from.</param>
		/// <param name="context">Current <typeparamref name="TContext"/>.</param>
		/// <param name="includeGenerationAttributes">Determines whether to apply the <see cref="Generator.DurianGeneratedAttribute"/> and <see cref="System.CodeDom.Compiler.GeneratedCodeAttribute"/> attributes to the generated node.</param>
		/// <param name="applyInheritdoc">Determines when to apply the <c>&lt;inheritdoc/&gt;</c> tag.</param>
		protected void WriteGeneratedMembers(
			string[] generated,
			IMemberData original,
			TContext context,
			bool includeGenerationAttributes = true,
			GenerateDocumentation applyInheritdoc = GenerateDocumentation.WhenPossible
		)
		{
			if (generated.Length == 0)
			{
				return;
			}

			if (TryGetInheritdoc(original, applyInheritdoc, out string? inheritdoc))
			{
				if(includeGenerationAttributes)
				{
					string generatedFrom = AutoGenerated.GetDurianGeneratedAttribute(SymbolToString(original.Symbol));
					WriteGeneratedMember_Internal(generated[0], generatedFrom, inheritdoc, context);

					for (int i = 1; i < generated.Length; i++)
					{
						context.CodeBuilder.NewLine();
						WriteGeneratedMember_Internal(generated[i], generatedFrom, inheritdoc, context);
					}
				}
				else
				{
					context.CodeBuilder.Indent();
					context.CodeBuilder.WriteLine(inheritdoc);
					context.CodeBuilder.Indent();
					context.CodeBuilder.WriteLine(generated[0]);
					context.CodeBuilder.NewLine();

					for (int i = 1; i < generated.Length; i++)
					{
						context.CodeBuilder.NewLine();
						context.CodeBuilder.Indent();
						context.CodeBuilder.WriteLine(inheritdoc);
						context.CodeBuilder.Indent();
						context.CodeBuilder.WriteLine(generated[i]);
						context.CodeBuilder.NewLine();
					}
				}
			}
			else
			{
				if(includeGenerationAttributes)
				{
					string generatedFrom = AutoGenerated.GetDurianGeneratedAttribute(SymbolToString(original.Symbol));
					WriteGeneratedMember_Internal(generated[0], generatedFrom, context);

					for (int i = 1; i < generated.Length; i++)
					{
						context.CodeBuilder.NewLine();
						WriteGeneratedMember_Internal(generated[i], generatedFrom, context);
					}
				}
				else
				{
					context.CodeBuilder.Indent();
					context.CodeBuilder.WriteLine(generated[0]);
					context.CodeBuilder.NewLine();

					for (int i = 1; i < generated.Length; i++)
					{
						context.CodeBuilder.NewLine();
						context.CodeBuilder.Indent();
						context.CodeBuilder.WriteLine(generated[i]);
						context.CodeBuilder.NewLine();
					}
				}
			}
		}

		/// <summary>
		/// Writes all the <paramref name="generated"/> <see cref="SyntaxNode"/>s and applies all needed code generation attributes.
		/// </summary>
		/// <param name="generated"><see cref="SyntaxNode"/>s that were generated during the current generation pass.</param>
		/// <param name="original"><see cref="ISymbol"/> this <see cref="SyntaxNode"/>s were generated from.</param>
		/// <param name="context">Current <typeparamref name="TContext"/>.</param>
		/// <param name="includeGenerationAttributes">Determines whether to apply the <see cref="Generator.DurianGeneratedAttribute"/> and <see cref="System.CodeDom.Compiler.GeneratedCodeAttribute"/> attributes to the generated node.</param>
		/// <param name="applyInheritdoc">Determines when to apply the <c>&lt;inheritdoc/&gt;</c> tag.</param>
		protected void WriteGeneratedMembers(
			SyntaxNode[] generated,
			ISymbol original,
			TContext context,
			bool includeGenerationAttributes = true,
			GenerateDocumentation applyInheritdoc = GenerateDocumentation.WhenPossible
		)
		{
			WriteGeneratedMembers(ConvertString(generated), original, context, includeGenerationAttributes, applyInheritdoc);
		}

		/// <summary>
		/// Writes all the <paramref name="generated"/> <see cref="string"/>s and applies all needed code generation attributes.
		/// </summary>
		/// <param name="generated"><see cref="string"/>s that were generated during the current generation pass.</param>
		/// <param name="original"><see cref="ISymbol"/> this <see cref="string"/>s were generated from.</param>
		/// <param name="context">Current <typeparamref name="TContext"/>.</param>
		/// <param name="includeGenerationAttributes">Determines whether to apply the <see cref="Generator.DurianGeneratedAttribute"/> and <see cref="System.CodeDom.Compiler.GeneratedCodeAttribute"/> attributes to the generated node.</param>
		/// <param name="applyInheritdoc">Determines when to apply the <c>&lt;inheritdoc/&gt;</c> tag.</param>
		protected void WriteGeneratedMembers(
			string[] generated,
			ISymbol original,
			TContext context,
			bool includeGenerationAttributes = true,
			GenerateDocumentation applyInheritdoc = GenerateDocumentation.WhenPossible)
		{
			if (generated.Length == 0)
			{
				return;
			}

			if (TryGetInheritdoc(original, applyInheritdoc, out string? inheritdoc))
			{
				if(includeGenerationAttributes)
				{
					string generatedFrom = AutoGenerated.GetDurianGeneratedAttribute(SymbolToString(original));
					WriteGeneratedMember_Internal(generated[0], generatedFrom, inheritdoc, context);

					for (int i = 1; i < generated.Length; i++)
					{
						context.CodeBuilder.NewLine();
						WriteGeneratedMember_Internal(generated[i], generatedFrom, inheritdoc, context);
					}
				}
				else
				{
					context.CodeBuilder.Indent();
					context.CodeBuilder.WriteLine(inheritdoc);
					context.CodeBuilder.Indent();
					context.CodeBuilder.WriteLine(generated[0]);
					context.CodeBuilder.NewLine();

					for (int i = 1; i < generated.Length; i++)
					{
						context.CodeBuilder.NewLine();
						context.CodeBuilder.Indent();
						context.CodeBuilder.WriteLine(inheritdoc);
						context.CodeBuilder.Indent();
						context.CodeBuilder.WriteLine(generated[i]);
						context.CodeBuilder.NewLine();
					}
				}
			}
			else
			{
				if(includeGenerationAttributes)
				{
					string generatedFrom = AutoGenerated.GetDurianGeneratedAttribute(SymbolToString(original));
					WriteGeneratedMember_Internal(generated[0], generatedFrom, context);

					for (int i = 1; i < generated.Length; i++)
					{
						context.CodeBuilder.NewLine();
						WriteGeneratedMember_Internal(generated[i], generatedFrom, context);
					}
				}
				else
				{
					context.CodeBuilder.Indent();
					context.CodeBuilder.WriteLine(generated[0]);
					context.CodeBuilder.NewLine();

					for (int i = 1; i < generated.Length; i++)
					{
						context.CodeBuilder.NewLine();
						context.CodeBuilder.Indent();
						context.CodeBuilder.WriteLine(generated[i]);
						context.CodeBuilder.NewLine();
					}
				}
			}
		}

		/// <summary>
		/// Writes the <see cref="System.CodeDom.Compiler.GeneratedCodeAttribute"/> and <see cref="Generator.DurianGeneratedAttribute"/> attributes.
		/// </summary>
		/// <param name="symbol"><see cref="ISymbol"/> the member was generated from.</param>
		/// <param name="context">Current <typeparamref name="TContext"/>.</param>
		protected void WriteGenerationAttributes(ISymbol symbol, TContext context)
		{
			context.CodeBuilder.Indent();
			context.CodeBuilder.WriteLine(_autoGeneratedAttribute);
			context.CodeBuilder.Indent();
			context.CodeBuilder.WriteLine(AutoGenerated.GetDurianGeneratedAttribute(SymbolToString(symbol)));
		}

		private protected static string NodeToString(SyntaxNode node)
		{
			return node.WithoutTrivia().ToFullString();
		}

		private protected static bool TryGetInheritdoc(IMemberData original, GenerateDocumentation applyInheritdoc, [NotNullWhen(true)] out string? inheritdoc)
		{
			switch (applyInheritdoc)
			{
				case GenerateDocumentation.Always:
					inheritdoc = AutoGenerated.GetInheritdoc(original.GetFullyQualifiedName(QualifiedName.Xml));
					return true;

				case GenerateDocumentation.WhenPossible:

					string? doc = original.Symbol.GetInheritdocIfHasDocumentation();

					if (!string.IsNullOrWhiteSpace(doc))
					{
						inheritdoc = doc!;
						return true;
					}

					break;
			}

			inheritdoc = null;
			return false;
		}

		private protected static bool TryGetInheritdoc(ISymbol original, GenerateDocumentation applyInheritdoc, [NotNullWhen(true)] out string? inheritdoc)
		{
			switch (applyInheritdoc)
			{
				case GenerateDocumentation.Always:
					inheritdoc = AutoGenerated.GetInheritdoc(original.GetFullyQualifiedName(QualifiedName.Xml));
					return true;

				case GenerateDocumentation.WhenPossible:

					string? doc = original.GetInheritdocIfHasDocumentation();

					if (!string.IsNullOrWhiteSpace(doc))
					{
						inheritdoc = doc!;
						return true;
					}

					break;
			}

			inheritdoc = null;
			return false;
		}

		private protected void WriteGeneratedMember_Internal(string generated, string generatedFrom, TContext context)
		{
			context.CodeBuilder.Indent();
			context.CodeBuilder.WriteLine(_autoGeneratedAttribute);
			context.CodeBuilder.Indent();
			context.CodeBuilder.WriteLine(generatedFrom);
			context.CodeBuilder.Indent();
			context.CodeBuilder.WriteLine(generated);
			context.CodeBuilder.NewLine();
		}

		private protected void WriteGeneratedMember_Internal(string generated, string generatedFrom, string inheritdoc, TContext context)
		{
			context.CodeBuilder.Indent();
			context.CodeBuilder.WriteLine(inheritdoc);
			WriteGeneratedMember_Internal(generated, generatedFrom, context);
		}

		private static string[] ConvertString(SyntaxNode[] nodes)
		{
			return nodes.Select(n => NodeToString(n)).ToArray();
		}

		private static SyntaxTree ParseSyntaxTree(TContext context)
		{
			return CSharpSyntaxTree.ParseText(context.CodeBuilder.ToString(), context.ParseOptions as CSharpParseOptions, encoding: Encoding.UTF8);
		}
	}

	/// <inheritdoc cref="DurianGeneratorWithBuilder{TContext}"/>
	public abstract class DurianGeneratorWithBuilder : DurianGeneratorWithBuilder<GeneratorPassBuilderContext>
	{
		/// <summary>
		/// Initializes a new instance of the <see cref="DurianGeneratorWithBuilder"/> class.
		/// </summary>
		protected DurianGeneratorWithBuilder()
		{
		}

		/// <summary>
		/// Initializes a new instance of the <see cref="DurianGeneratorWithBuilder"/> class.
		/// </summary>
		/// <param name="context">Configures how this <see cref="DurianGeneratorWithBuilder"/> is initialized.</param>
		protected DurianGeneratorWithBuilder(in GeneratorLogCreationContext context) : base(in context)
		{
		}

		/// <summary>
		/// Initializes a new instance of the <see cref="DurianGeneratorWithBuilder"/> class.
		/// </summary>
		/// <param name="loggingConfiguration">Determines how the source generator should behave when logging information.</param>
		protected DurianGeneratorWithBuilder(LoggingConfiguration? loggingConfiguration) : base(loggingConfiguration)
		{
		}

		/// <inheritdoc/>
		protected override GeneratorPassBuilderContext CreateCurrentPassContext(ICompilationData currentCompilation, in GeneratorExecutionContext context)
		{
			return new GeneratorPassBuilderContext();
		}
	}
}
