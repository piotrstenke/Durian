using System;
using System.Runtime.CompilerServices;
using Durian.Analysis;
using Durian.Analysis.CodeGeneration;
using Durian.Analysis.Logging;
using Microsoft.CodeAnalysis;

namespace Durian.TestServices;

/// <summary>
/// An abstract class that provides methods to test <see cref="IDurianGenerator"/>s and log information about the generator test.
/// </summary>
/// <typeparam name="T">Type of target <see cref="IDurianGenerator"/>.</typeparam>
public abstract class DurianGeneratorTest<T> : LoggableGeneratorTest<ITestableGenerator>, IDisposable where T : IDurianGenerator
{
	/// <summary>
	/// Underlaying source generator to test.
	/// </summary>
	public T UnderlayingGenerator { get; }

	/// <summary>
	/// Initializes a new instance of the <see cref="DurianGeneratorTest{T}"/> class.
	/// </summary>
	protected DurianGeneratorTest() : this(true)
	{
	}

	/// <summary>
	/// Initializes a new instance of the <see cref="DurianGeneratorTest{T}"/> class.
	/// </summary>
	/// <param name="enableDiagnostics">Determines whether to enable diagnostics for the created <see cref="IDurianGenerator"/> if it supports any.</param>
	protected DurianGeneratorTest(bool enableDiagnostics) : base(enableDiagnostics, typeof(T))
	{
		UnderlayingGenerator = CreateUnderlayingGenerator(_configuration);

		if(UnderlayingGenerator is not IIncrementalGenerator and not ISourceGenerator)
		{
			throw new InvalidOperationException($"{nameof(UnderlayingGenerator)} does not implement the {nameof(ISourceGenerator)} or {nameof(IIncrementalGenerator)} interfaces");
		}
	}

	/// <inheritdoc/>
	public void Dispose()
	{
		Dispose(true);
		GC.SuppressFinalize(this);
	}

	/// <summary>
	/// Provides text of the <see cref="Generator.DurianGeneratedAttribute"/> and <see cref="System.CodeDom.Compiler.GeneratedCodeAttribute"/>,
	/// </summary>
	/// <param name="source">Parameter to pass to the attributes' constructor.</param>
	/// <param name="indent">Indent level to apply.</param>
	public string GetCodeGenerationAttributes(string? source, int indent = 1)
	{
		return AutoGenerated.GetCodeGenerationAttributes(UnderlayingGenerator.GeneratorName, UnderlayingGenerator.GeneratorVersion, source, indent);
	}

	/// <inheritdoc/>
	public sealed override SingleGeneratorTestResult RunGenerator(string? input, int index, [CallerMemberName] string testName = "")
	{
		return base.RunGenerator(input, UnderlayingGenerator.NumStaticTrees + index, testName);
	}

	/// <inheritdoc/>
	public sealed override SingleGeneratorTestResult RunGenerator(string? input, [CallerMemberName] string testName = "")
	{
		return base.RunGenerator(input, UnderlayingGenerator.NumStaticTrees, testName);
	}

	/// <inheritdoc/>
	public sealed override SingleGeneratorTestResult RunGeneratorWithDependency(string? input, string external, int index, [CallerMemberName] string testName = "")
	{
		return base.RunGeneratorWithDependency(input, external, UnderlayingGenerator.NumStaticTrees + index, testName);
	}

	/// <inheritdoc/>
	public sealed override SingleGeneratorTestResult RunGeneratorWithDependency(string? input, string external, [CallerMemberName] string testName = "")
	{
		return base.RunGeneratorWithDependency(input, external, UnderlayingGenerator.NumStaticTrees, testName);
	}

	/// <inheritdoc/>
	public override MultipleGeneratorTestResult RunGeneratorWithMultipleOutputs(string? input, [CallerMemberName] string testName = "")
	{
		return base.RunGeneratorWithMultipleOutputs(input, UnderlayingGenerator.NumStaticTrees, testName);
	}

	/// <inheritdoc/>
	public override MultipleGeneratorTestResult RunGeneratorWithMultipleOutputs(string? input, int startIndex, [CallerMemberName] string testName = "")
	{
		return base.RunGeneratorWithMultipleOutputs(input, UnderlayingGenerator.NumStaticTrees + startIndex, testName);
	}

	/// <inheritdoc/>
	protected sealed override ITestableGenerator CreateGenerator(LoggingConfiguration configuration, string testName)
	{
		return CreateTestableGenerator(testName);
	}

	/// <summary>
	/// Creates an <see cref="ITestableGenerator"/> for the current test.
	/// </summary>
	/// <param name="testName">Name of the current test.</param>
	protected virtual ITestableGenerator CreateTestableGenerator(string testName)
	{
		if(UnderlayingGenerator is DurianIncrementalGenerator i)
		{
			return i.CreateTestable(testName);
		}

		throw new InvalidOperationException($"Could not automatically create a new {nameof(ITestableGenerator)}. Consider overriding the {nameof(CreateTestableGenerator)} method");
	}

	/// <summary>
	/// Creates the underlaying <typeparamref name="T"/> generator.
	/// </summary>
	/// <param name="configuration">Configuration for the <see cref="IDurianGenerator"/>.</param>
	protected virtual T CreateUnderlayingGenerator(LoggingConfiguration configuration)
	{
		return (T)Activator.CreateInstance(typeof(T), configuration);
	}

	/// <summary>
	/// Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
	/// </summary>
	/// <param name="disposing">Determines whether this method was called from the <see cref="IDisposable.Dispose"/> method or object's finalizer.</param>
	protected virtual void Dispose(bool disposing)
	{
		if (disposing)
		{
			UnderlayingGenerator.Dispose();
		}
	}
}
