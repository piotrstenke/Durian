using Xunit;
using Durian.Generator;
using Microsoft.CodeAnalysis.Diagnostics;
using Microsoft.CodeAnalysis;
using System.Text;
using Microsoft.CodeAnalysis.CSharp;
using System.Threading.Tasks;
using System.Collections.Immutable;
using Durian.Info;

namespace Durian.Tests.Core
{
	public sealed class TypeImportTests
	{
		[Fact]
		public async Task UsingStatementWithGeneratorNamespaceDoesNotProduceError()
		{
			string input =
$@"using {DurianStrings.GeneratorNamespace};

class Test
{{
}}
";
			Assert.Empty(await RunAnalyzer(new TypeImportAnalyzer(), input));
		}

		[Fact]
		public async Task Error_When_AddedCustomTypeToGeneratorNamespace()
		{
			string input =
$@"namespace Durian.Generator
{{
	class Test
	{{
	}}
}}
";
			Assert.Contains(await RunAnalyzer(new CustomTypesInGeneratorNamespaceAnalyzer(), input), d => d.Id == DurianDiagnostics.DUR0005_DoNotAddTypesToGeneratorNamespace.Id);
		}

		[Fact]
		public async Task Error_When_UsesTypeFromGeneratorNamespace()
		{
			string input =
$@"using {DurianStrings.GeneratorNamespace};

[{nameof(DurianGeneratedAttribute)}]
class Test
{{
	
}}
";
			Assert.Contains(await RunAnalyzer(new TypeImportAnalyzer(), input), d => d.Id == DurianDiagnostics.DUR0003_DoNotUseTypeFromDurianGeneratorNamespace.Id);
		}

		[Fact]
		public async Task Error_When_UsesTypeFromGeneratorNamespaceAsAlias()
		{
			string input =
$@"using A = {DurianStrings.GeneratorNamespace}.{nameof(DurianGeneratedAttribute)};

[A]
class Test
{{
	
}}
";
			Assert.Contains(await RunAnalyzer(new TypeImportAnalyzer(), input), d => d.Id == DurianDiagnostics.DUR0003_DoNotUseTypeFromDurianGeneratorNamespace.Id);
		}

		[Fact]
		public async Task Error_When_UsesTypeFromGeneratorNamespaceInGenericName()
		{
			string input =
$@"using {DurianStrings.GeneratorNamespace};
using System.Collections.Generic;

class Test
{{
	public void Method()
	{{
		List<{nameof(DurianGeneratedAttribute)}> list = new();
	}}
}}
";
			Assert.Contains(await RunAnalyzer(new TypeImportAnalyzer(), input), d => d.Id == DurianDiagnostics.DUR0003_DoNotUseTypeFromDurianGeneratorNamespace.Id);
		}

		[Fact]
		public async Task Error_When_UsesTypeFromGeneratorNamespaceInFullyQualifiedName()
		{
			string input =
$@"[{DurianStrings.GeneratorNamespace}.{nameof(DurianGeneratedAttribute)}]
class Test
{{
	
}}
";
			Assert.Contains(await RunAnalyzer(new TypeImportAnalyzer(), input), d => d.Id == DurianDiagnostics.DUR0003_DoNotUseTypeFromDurianGeneratorNamespace.Id);
		}

		[Fact]
		public async Task Error_WhenUsesNotImportedType()
		{
			string input =
$@"using {DurianStrings.MainNamespace};

class Test<[{nameof(DefaultParamAttribute)}(typeof(string))]T>
{{

}}
";

			Assert.Contains(await RunAnalyzer(new TypeImportAnalyzer(), input), d => d.Id == DurianDiagnostics.DUR0002_ModuleOfTypeIsNotImported.Id);
		}

		[Fact]
		public async Task Success_When_TypeIsImported()
		{
			string input =
$@"using {DurianStrings.MainNamespace};

class Test<[{nameof(DefaultParamAttribute)}(typeof(string))]T>
{{

}}
";

			Assert.Empty(await RunAnalyzer(new TypeImportAnalyzer(), input, nameof(DurianModule.DefaultParam)));
		}

		private static Task<ImmutableArray<Diagnostic>> RunAnalyzer(DiagnosticAnalyzer analyzer, string input)
		{
			return RunAnalyzer(analyzer, input, nameof(DurianModule.Core));
		}

		private static Task<ImmutableArray<Diagnostic>> RunAnalyzer(DiagnosticAnalyzer analyzer, string input, string module)
		{
			string moduleMock =
@$"{AutoGenerated.GetHeader()}

[assembly: {DurianStrings.GeneratorNamespace}.{nameof(EnableModuleAttribute)}({DurianStrings.InfoNamespace}.{nameof(DurianModule)}.{module})]";

			SyntaxTree generatedTree = CSharpSyntaxTree.ParseText(moduleMock, encoding: Encoding.UTF8);
			SyntaxTree tree = CSharpSyntaxTree.ParseText(input, encoding: Encoding.UTF8);
			CSharpCompilation compilation = RoslynUtilities.CreateBaseCompilation();
			compilation = compilation.AddSyntaxTrees(generatedTree, tree);

			return analyzer.RunAnalyzer(compilation);
		}
	}
}
